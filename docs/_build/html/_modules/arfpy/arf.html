<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>arfpy.arf &mdash; arfpy 0.1.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=87f11076"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            arfpy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Module Documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">arfpy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../arfpy.html">arfpy package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../arfpy.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../arfpy.html#module-arfpy.arf">arfpy.arf module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../arfpy.html#arfpy.arf.arf"><code class="docutils literal notranslate"><span class="pre">arf</span></code></a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../arfpy.html#arfpy.arf.arf.forde"><code class="docutils literal notranslate"><span class="pre">arf.forde()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="../../arfpy.html#arfpy.arf.arf.forge"><code class="docutils literal notranslate"><span class="pre">arf.forge()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../arfpy.html#module-arfpy.utils">arfpy.utils module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../arfpy.html#arfpy.utils.bnd_fun"><code class="docutils literal notranslate"><span class="pre">bnd_fun()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../arfpy.html#module-arfpy">Module contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../examples/twomoons.html">Twomoons data example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/digits.html">Digit zero data example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/mvnorm.html">Density estimation: multivariate normal distribution</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">arfpy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">arfpy.arf</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for arfpy.arf</h1><div class="highlight"><pre>
<span></span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">RandomForestClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble._forest</span> <span class="kn">import</span> <span class="n">_generate_unsampled_indices</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">from</span> <span class="nn">arfpy</span> <span class="kn">import</span> <span class="n">utils</span>

<div class="viewcode-block" id="arf"><a class="viewcode-back" href="../../arfpy.html#arfpy.arf.arf">[docs]</a><span class="k">class</span> <span class="nc">arf</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Implements Adversarial Random Forests (ARF) in python</span>
<span class="sd">  Usage:</span>
<span class="sd">  1. fit ARF model with arf()</span>
<span class="sd">  2. estimate density with arf.forde()</span>
<span class="sd">  3. generate data with arf.forge().</span>

<span class="sd">  :param x: Input data.</span>
<span class="sd">  :type x: pandas.Dataframe</span>
<span class="sd">  :param num_trees:  Number of trees to grow in each forest, defaults to 30</span>
<span class="sd">  :type num_trees: int, optional</span>
<span class="sd">  :param delta: Tolerance parameter. Algorithm converges when OOB accuracy is &lt; 0.5 + `delta`, defaults to 0</span>
<span class="sd">  :type delta: float, optional</span>
<span class="sd">  :param max_iters: Maximum iterations for the adversarial loop, defaults to 10</span>
<span class="sd">  :type max_iters: int, optional</span>
<span class="sd">  :param early_stop: Terminate loop if performance fails to improve from one round to the next?, defaults to True</span>
<span class="sd">  :type early_stop: bool, optional</span>
<span class="sd">  :param verbose: Print discriminator accuracy after each round?, defaults to True</span>
<span class="sd">  :type verbose: bool, optional</span>
<span class="sd">  :param min_node_size: minimum number of samples in terminal node, defaults to 5 </span>
<span class="sd">  :type min_node_size: int</span>
<span class="sd">  &quot;&quot;&quot;</span>   
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span>  <span class="n">num_trees</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>  <span class="n">max_iters</span> <span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">early_stop</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">min_node_size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
 
    <span class="n">x_real</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">x_real</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">orig_colnames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x_real</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">num_trees</span> <span class="o">=</span> <span class="n">num_trees</span>

    <span class="c1"># Find object columns and convert to category</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">object_cols</span> <span class="o">=</span> <span class="n">x_real</span><span class="o">.</span><span class="n">dtypes</span> <span class="o">==</span> <span class="s2">&quot;object&quot;</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">x_real</span><span class="p">):</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">object_cols</span><span class="p">[</span><span class="n">col</span><span class="p">]:</span>
        <span class="n">x_real</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_real</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
    
    <span class="c1"># Find factor columns</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">factor_cols</span> <span class="o">=</span> <span class="n">x_real</span><span class="o">.</span><span class="n">dtypes</span> <span class="o">==</span> <span class="s2">&quot;category&quot;</span>
    
    <span class="c1"># Save factor levels</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">x_real</span><span class="p">):</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_cols</span><span class="p">[</span><span class="n">col</span><span class="p">]:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_real</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span>
    
    <span class="c1"># Recode factors to integers</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">x_real</span><span class="p">):</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_cols</span><span class="p">[</span><span class="n">col</span><span class="p">]:</span>
        <span class="n">x_real</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_real</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span>
    
    <span class="c1"># If no synthetic data provided, sample from marginals</span>
    <span class="n">x_synth</span> <span class="o">=</span> <span class="n">x_real</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">frac</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    
    <span class="c1"># Merge real and synthetic data</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">x_real</span><span class="p">,</span> <span class="n">x_synth</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x_real</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x_real</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
    <span class="c1"># real observations = 0, synthetic observations = 1</span>

    <span class="c1"># pass on x_real</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">x_real</span> <span class="o">=</span> <span class="n">x_real</span>

    <span class="c1"># Fit initial RF model</span>
    <span class="n">clf_0</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">(</span> <span class="n">oob_score</span><span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">n_estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trees</span><span class="p">,</span><span class="n">min_samples_leaf</span><span class="o">=</span><span class="n">min_node_size</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> 
    <span class="n">clf_0</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="n">iters</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">acc_0</span> <span class="o">=</span> <span class="n">clf_0</span><span class="o">.</span><span class="n">oob_score_</span> <span class="c1"># is accuracy directly</span>
    <span class="n">acc</span> <span class="o">=</span> <span class="p">[</span><span class="n">acc_0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
      <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Initial accuracy is </span><span class="si">{</span><span class="n">acc_0</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">acc_0</span> <span class="o">&gt;</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">delta</span> <span class="ow">and</span> <span class="n">iters</span> <span class="o">&lt;</span> <span class="n">max_iters</span><span class="p">):</span>
      <span class="n">converged</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="k">while</span> <span class="p">(</span><span class="ow">not</span> <span class="n">converged</span><span class="p">):</span> <span class="c1"># Start adversarial loop</span>
        <span class="c1"># get nodeIDs</span>
        <span class="n">nodeIDs</span> <span class="o">=</span> <span class="n">clf_0</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_real</span><span class="p">)</span> <span class="c1"># dimension [terminalnode, tree]</span>

        <span class="c1"># add observation ID to x_real</span>
        <span class="n">x_real_obs</span> <span class="o">=</span> <span class="n">x_real</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">x_real_obs</span><span class="p">[</span><span class="s1">&#39;obs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">x_real</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># add observation ID to nodeIDs</span>
        <span class="n">nodeIDs_pd</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">nodeIDs</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">nodeIDs_pd</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1">#tmp.columns = [ &quot;tree&quot; + str(c) for c in tmp.columns ]</span>
        <span class="n">tmp</span><span class="p">[</span><span class="s1">&#39;obs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">x_real</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;obs&#39;</span><span class="p">],</span> <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;leaf&quot;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;tree&quot;</span><span class="p">)</span>

        <span class="c1"># match real data to trees and leafs (node id for tree)</span>
        <span class="n">x_real_obs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">x_real_obs</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">tmp</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;obs&#39;</span><span class="p">],</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">x_real_obs</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;obs&#39;</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># sample leafs</span>
        <span class="n">tmp</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;obs&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">x_real</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">sort</span> <span class="o">=</span> <span class="kc">False</span> <span class="p">),</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;cnt&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">draw_from</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">left</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">x_real_obs</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;tree&#39;</span><span class="p">,</span> <span class="s1">&#39;leaf&#39;</span><span class="p">],</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>

        <span class="c1"># sample synthetic data from leaf</span>
        <span class="n">grpd</span> <span class="o">=</span>  <span class="n">draw_from</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;tree&#39;</span><span class="p">,</span> <span class="s1">&#39;leaf&#39;</span><span class="p">])</span>
        <span class="n">x_synth</span> <span class="o">=</span> <span class="p">[</span><span class="n">grpd</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">grpd</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">ind</span><span class="p">)[</span><span class="s1">&#39;cnt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">grpd</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">x_synth</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">x_synth</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;cnt&#39;</span><span class="p">,</span> <span class="s1">&#39;tree&#39;</span><span class="p">,</span> <span class="s1">&#39;leaf&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># delete unnecessary objects </span>
        <span class="k">del</span><span class="p">(</span><span class="n">nodeIDs</span><span class="p">,</span> <span class="n">nodeIDs_pd</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">x_real_obs</span><span class="p">,</span> <span class="n">draw_from</span><span class="p">)</span>

        <span class="c1"># merge real and synthetic data</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">x_real</span><span class="p">,</span> <span class="n">x_synth</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x_real</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x_real</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
        
        <span class="c1"># discrimintator</span>
        <span class="n">clf_1</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">(</span> <span class="n">oob_score</span><span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">n_estimators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trees</span><span class="p">,</span> <span class="n">min_samples_leaf</span><span class="o">=</span><span class="n">min_node_size</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> 
        <span class="n">clf_1</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="c1"># update iters and check for convergence</span>
        <span class="n">acc_1</span> <span class="o">=</span> <span class="n">clf_1</span><span class="o">.</span><span class="n">oob_score_</span>
        
        <span class="n">acc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">acc_1</span><span class="p">)</span>
        
        <span class="n">iters</span> <span class="o">=</span> <span class="n">iters</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">plateau</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">early_stop</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">acc</span><span class="p">[</span><span class="n">iters</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">acc</span><span class="p">[</span><span class="n">iters</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
          <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Iteration number </span><span class="si">{</span><span class="n">iters</span><span class="si">}</span><span class="s2"> reached accuracy of </span><span class="si">{</span><span class="n">acc_1</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">acc_1</span> <span class="o">&lt;=</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">delta</span> <span class="ow">or</span> <span class="n">iters</span> <span class="o">&gt;=</span> <span class="n">max_iters</span> <span class="ow">or</span> <span class="n">plateau</span><span class="p">):</span>
          <span class="n">converged</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">clf_0</span> <span class="o">=</span> <span class="n">clf_1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">clf</span> <span class="o">=</span> <span class="n">clf_0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">acc</span> <span class="o">=</span> <span class="n">acc</span> 
        
    <span class="c1"># Pruning</span>
    <span class="n">pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clf</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_real</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">tree_num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trees</span><span class="p">):</span>
      <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clf</span><span class="o">.</span><span class="n">estimators_</span><span class="p">[</span><span class="n">tree_num</span><span class="p">]</span>
      <span class="n">left</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">tree_</span><span class="o">.</span><span class="n">children_left</span>
      <span class="n">right</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">tree_</span><span class="o">.</span><span class="n">children_right</span>
      <span class="n">leaves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

      <span class="c1"># get leaves that are too small</span>
      <span class="n">unique</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pred</span><span class="p">[:,</span> <span class="n">tree_num</span><span class="p">],</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">to_prune</span> <span class="o">=</span> <span class="n">unique</span><span class="p">[</span><span class="n">counts</span> <span class="o">&lt;</span> <span class="n">min_node_size</span><span class="p">]</span>

      <span class="c1"># also add leaves with 0 obs.</span>
      <span class="n">to_prune</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">to_prune</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">leaves</span><span class="p">,</span> <span class="n">unique</span><span class="p">)])</span>

      <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_prune</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="n">to_prune</span><span class="p">:</span>
          <span class="c1"># Find parent</span>
          <span class="n">parent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">tp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
          <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Left child</span>
            <span class="n">left</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span> <span class="o">=</span> <span class="n">right</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Right child</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">right</span> <span class="o">==</span> <span class="n">tp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">right</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span>
        <span class="c1"># Prune again if child was pruned</span>
        <span class="n">to_prune</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">to_prune</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="arf.forde"><a class="viewcode-back" href="../../arfpy.html#arfpy.arf.arf.forde">[docs]</a>  <span class="k">def</span> <span class="nf">forde</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="s2">&quot;truncnorm&quot;</span><span class="p">,</span> <span class="n">oob</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This part is for density estimation (FORDE)</span>

<span class="sd">    :param dist: Distribution to use for density estimation of continuous features. Distributions implemented so far: &quot;truncnorm&quot;, defaults to &quot;truncnorm&quot;</span>
<span class="sd">    :type dist: str, optional</span>
<span class="sd">    :param oob: Only use out-of-bag samples for parameter estimation? If `True`, `x` must be the same dataset used to train `arf`, defaults to False</span>
<span class="sd">    :type oob: bool, optional</span>
<span class="sd">    :param alpha: Optional pseudocount for Laplace smoothing of categorical features. This avoids zero-mass points when test data fall outside the support of training data. Effectively parametrizes a flat Dirichlet prior on multinomial likelihoods, defaults to 0</span>
<span class="sd">    :type alpha: float, optional</span>
<span class="sd">    :return: Return parameters for the estimated density.</span>
<span class="sd">    :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>    
 
    <span class="bp">self</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">oob</span> <span class="o">=</span> <span class="n">oob</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>

    <span class="c1"># Get terminal nodes for all observations</span>
    <span class="n">pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clf</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_real</span><span class="p">)</span>
    
    <span class="c1"># If OOB, use only OOB trees</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">oob</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trees</span><span class="p">):</span>
        <span class="n">idx_oob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_real</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">_generate_unsampled_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clf</span><span class="o">.</span><span class="n">estimators_</span><span class="p">[</span><span class="n">tree</span><span class="p">]</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">pred</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">idx_oob</span><span class="p">),</span> <span class="n">tree</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    
    <span class="c1"># Get probabilities of terminal nodes for each tree </span>
    <span class="c1"># node_probs dims: [nodeid, tree]</span>
    <span class="c1">#self.node_probs = np.apply_along_axis(func1d= utils.bincount, axis = 0, arr =pred, nbins = np.max(pred))</span>
    
    <span class="c1"># compute leaf bounds and coverage</span>
    <span class="n">bnds</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">utils</span><span class="o">.</span><span class="n">bnd_fun</span><span class="p">(</span><span class="n">tree</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">forest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clf</span><span class="p">,</span> <span class="n">feature_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_colnames</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trees</span><span class="p">)])</span>
    <span class="n">bnds</span><span class="p">[</span><span class="s1">&#39;f_idx&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">bnds</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;tree&#39;</span><span class="p">,</span> <span class="s1">&#39;leaf&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">ngroup</span><span class="p">()</span>

    <span class="n">bnds_2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trees</span><span class="p">):</span>
      <span class="n">unique</span><span class="p">,</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pred</span><span class="p">[:,</span><span class="n">t</span><span class="p">],</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">vv</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">unique</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;leaf&#39;</span><span class="p">),</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">freq</span><span class="o">/</span><span class="n">pred</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;cvg&#39;</span><span class="p">)],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
      <span class="n">zz</span> <span class="o">=</span> <span class="n">bnds</span><span class="p">[</span><span class="n">bnds</span><span class="p">[</span><span class="s1">&#39;tree&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">]</span>
      <span class="n">bnds_2</span> <span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">bnds_2</span><span class="p">,</span><span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">vv</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">zz</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;leaf&#39;</span><span class="p">])])</span>
    <span class="n">bnds</span> <span class="o">=</span> <span class="n">bnds_2</span>
    <span class="k">del</span><span class="p">(</span><span class="n">bnds_2</span><span class="p">)</span>

    <span class="c1"># set coverage for nodes with single observations to zero</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factor_cols</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
      <span class="n">bnds</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">bnds</span><span class="p">[</span><span class="s1">&#39;cvg&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">/</span><span class="n">pred</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;cvg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># no parameters to learn for zero coverage leaves - drop zero coverage nodes</span>
    <span class="n">bnds</span> <span class="o">=</span> <span class="n">bnds</span><span class="p">[</span><span class="n">bnds</span><span class="p">[</span><span class="s1">&#39;cvg&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c1"># rename leafs to nodeids</span>
    <span class="n">bnds</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;leaf&#39;</span><span class="p">:</span> <span class="s1">&#39;nodeid&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># save bounds to later use coverage for drawing new samples</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">bnds</span><span class="o">=</span> <span class="n">bnds</span>
    <span class="c1"># Fit continuous distribution in all terminal nodes</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factor_cols</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
      <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trees</span><span class="p">):</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_real</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factor_cols</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">dt</span><span class="p">[</span><span class="s2">&quot;tree&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span>
        <span class="n">dt</span><span class="p">[</span><span class="s2">&quot;nodeid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pred</span><span class="p">[:,</span><span class="n">tree</span><span class="p">]</span>
        <span class="c1"># merge bounds and make it long format</span>
        <span class="n">long</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">right</span> <span class="o">=</span> <span class="n">bnds</span><span class="p">[[</span><span class="s1">&#39;tree&#39;</span><span class="p">,</span> <span class="s1">&#39;nodeid&#39;</span><span class="p">,</span><span class="s1">&#39;variable&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;f_idx&#39;</span><span class="p">]],</span> <span class="n">left</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="n">dt</span><span class="p">[</span><span class="s2">&quot;nodeid&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">],</span> <span class="n">id_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;tree&quot;</span><span class="p">,</span> <span class="s2">&quot;nodeid&quot;</span><span class="p">]),</span> <span class="n">on</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;tree&#39;</span><span class="p">,</span> <span class="s1">&#39;nodeid&#39;</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">],</span> <span class="n">how</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span><span class="p">)</span>
        <span class="c1"># get distribution parameters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span> <span class="o">==</span> <span class="s2">&quot;truncnorm&quot;</span><span class="p">:</span>
          <span class="n">res</span> <span class="o">=</span> <span class="n">long</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span> <span class="s1">&#39;tree&#39;</span><span class="p">,</span><span class="s2">&quot;nodeid&quot;</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span><span class="p">],</span> <span class="n">as_index</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">),</span> <span class="n">sd</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">),</span> <span class="nb">min</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="s2">&quot;min&quot;</span><span class="p">),</span> <span class="nb">max</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Other distributions not yet implemented&#39;</span><span class="p">)</span>
          <span class="n">exit</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">res</span><span class="p">])</span>
    
    <span class="c1"># Get class probabilities in all terminal nodes</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">class_probs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_cols</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
      <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trees</span><span class="p">):</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_real</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_cols</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">dt</span><span class="p">[</span><span class="s2">&quot;tree&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span>
        <span class="n">dt</span><span class="p">[</span><span class="s2">&quot;nodeid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pred</span><span class="p">[:,</span><span class="n">tree</span><span class="p">]</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="n">dt</span><span class="p">[</span><span class="s2">&quot;nodeid&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">],</span> <span class="n">id_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;tree&quot;</span><span class="p">,</span> <span class="s2">&quot;nodeid&quot;</span><span class="p">])</span>
        <span class="n">long</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">left</span> <span class="o">=</span> <span class="n">dt</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">bnds</span><span class="p">,</span> <span class="n">on</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;tree&#39;</span><span class="p">,</span><span class="s1">&#39;nodeid&#39;</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">])</span>
        <span class="n">long</span><span class="p">[</span><span class="s1">&#39;count_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">long</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;tree&#39;</span><span class="p">,</span> <span class="s1">&#39;nodeid&#39;</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">])[</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="s1">&#39;count&#39;</span><span class="p">)</span>
        <span class="n">long</span><span class="p">[</span><span class="s1">&#39;count_var_val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">long</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;tree&#39;</span><span class="p">,</span> <span class="s1">&#39;nodeid&#39;</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">])[</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="s1">&#39;count&#39;</span><span class="p">)</span>
        <span class="n">long</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
          <span class="n">long</span><span class="p">[</span><span class="s1">&#39;prob&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">long</span><span class="p">[</span><span class="s1">&#39;count_var_val&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">long</span><span class="p">[</span><span class="s1">&#39;count_var&#39;</span><span class="p">]</span> 
        <span class="k">else</span><span class="p">:</span>
          <span class="c1"># Define the range of each variable in each leaf</span>
          <span class="n">long</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">long</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;variable&#39;</span><span class="p">])[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="s1">&#39;nunique&#39;</span><span class="p">)</span>  
          <span class="n">long</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">long</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">)</span> <span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="mi">1</span>
          <span class="n">long</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">long</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span> <span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">long</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="mi">1</span>
          <span class="n">long</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">long</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mf">0.5</span> <span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">long</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span>
          <span class="n">long</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">long</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mf">0.5</span> <span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">long</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span>
          <span class="n">long</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">long</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">long</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">]</span>  
          <span class="c1"># Enumerate each possible leaf-variable-value combo</span>
          <span class="n">tmp</span> <span class="o">=</span> <span class="n">long</span><span class="p">[[</span><span class="s1">&#39;f_idx&#39;</span><span class="p">,</span><span class="s1">&#39;tree&#39;</span><span class="p">,</span> <span class="s2">&quot;nodeid&quot;</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span><span class="s1">&#39;max&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
          <span class="n">tmp</span><span class="p">[</span><span class="s1">&#39;rep_min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> 
          <span class="n">tmp</span><span class="p">[</span><span class="s1">&#39;rep_max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span> 
          <span class="n">tmp</span><span class="p">[</span><span class="s1">&#39;levels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span>  <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;rep_min&#39;</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;rep_max&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
          <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">explode</span><span class="p">(</span><span class="s1">&#39;levels&#39;</span><span class="p">)</span>
          <span class="n">cat_val</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span><span class="o">.</span><span class="n">melt</span><span class="p">()</span>
          <span class="n">cat_val</span><span class="p">[</span><span class="s1">&#39;levels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cat_val</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> 
          <span class="n">tmp</span> <span class="o">=</span>  <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">left</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">cat_val</span><span class="p">,</span> <span class="n">on</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;variable&#39;</span><span class="p">,</span> <span class="s1">&#39;levels&#39;</span><span class="p">])[[</span><span class="s1">&#39;variable&#39;</span><span class="p">,</span> <span class="s1">&#39;f_idx&#39;</span><span class="p">,</span><span class="s1">&#39;tree&#39;</span><span class="p">,</span> <span class="s2">&quot;nodeid&quot;</span><span class="p">,</span><span class="s1">&#39;value&#39;</span><span class="p">]]</span>
          <span class="c1"># populate count, k</span>
          <span class="n">tmp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">left</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">long</span><span class="p">[[</span><span class="s1">&#39;f_idx&#39;</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">,</span> <span class="s1">&#39;tree&#39;</span><span class="p">,</span> <span class="s2">&quot;nodeid&quot;</span><span class="p">,</span><span class="s1">&#39;count_var&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">]],</span> <span class="n">on</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;f_idx&#39;</span><span class="p">,</span> <span class="s2">&quot;nodeid&quot;</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">,</span> <span class="s1">&#39;tree&#39;</span><span class="p">])</span>
          <span class="c1"># Merge with long, set val_count = 0 for possible but unobserved levels</span>
          <span class="n">long</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">left</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">long</span><span class="p">,</span> <span class="n">on</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;f_idx&#39;</span><span class="p">,</span><span class="s1">&#39;tree&#39;</span><span class="p">,</span><span class="s2">&quot;nodeid&quot;</span><span class="p">,</span>  <span class="s1">&#39;variable&#39;</span><span class="p">,</span><span class="s1">&#39;value&#39;</span><span class="p">,</span><span class="s1">&#39;count_var&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">],</span> <span class="n">how</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span><span class="p">)</span>
          <span class="n">long</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">long</span><span class="p">[</span><span class="s1">&#39;count_var_val&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">(),</span> <span class="s1">&#39;count_var_val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
          <span class="n">long</span> <span class="o">=</span> <span class="n">long</span><span class="p">[[</span><span class="s1">&#39;f_idx&#39;</span><span class="p">,</span><span class="s1">&#39;tree&#39;</span><span class="p">,</span><span class="s2">&quot;nodeid&quot;</span><span class="p">,</span>  <span class="s1">&#39;variable&#39;</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="s1">&#39;count_var_val&#39;</span><span class="p">,</span> <span class="s1">&#39;count_var&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
          <span class="c1"># Compute posterior probabilities</span>
          <span class="n">long</span><span class="p">[</span><span class="s1">&#39;prob&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">long</span><span class="p">[</span><span class="s1">&#39;count_var_val&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">long</span><span class="p">[</span><span class="s1">&#39;count_var&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">*</span><span class="n">long</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">])</span>
          <span class="n">long</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">long</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int8&#39;</span><span class="p">)</span>
        
        <span class="n">long</span> <span class="o">=</span> <span class="n">long</span><span class="p">[[</span><span class="s1">&#39;f_idx&#39;</span><span class="p">,</span><span class="s1">&#39;tree&#39;</span><span class="p">,</span> <span class="s2">&quot;nodeid&quot;</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">,</span><span class="s1">&#39;prob&#39;</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_probs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">class_probs</span><span class="p">,</span> <span class="n">long</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;cnt&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="s2">&quot;cat&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_probs</span><span class="p">,</span> 
            <span class="s2">&quot;forest&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">clf</span><span class="p">,</span> <span class="s2">&quot;meta&quot;</span> <span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_colnames</span><span class="p">,</span> <span class="s2">&quot;family&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">})}</span></div>
  <span class="c1"># TO DO: optional -- think of dropping f_idx</span>
<div class="viewcode-block" id="arf.forge"><a class="viewcode-back" href="../../arfpy.html#arfpy.arf.arf.forge">[docs]</a>  <span class="k">def</span> <span class="nf">forge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This part is for data generation (FORGE)</span>

<span class="sd">    :param n: Number of synthetic samples to generate.</span>
<span class="sd">    :type n: int</span>
<span class="sd">    :return: Returns generated data.</span>
<span class="sd">    :rtype: pandas.DataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;bnds&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;need density estimates to generate data -- run .forde() first!&#39;</span><span class="p">)</span>

    <span class="c1"># Sample new observations and get their terminal nodes</span>
    <span class="c1"># Draw random leaves with probability proportional to coverage</span>
    <span class="n">unique_bnds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bnds</span><span class="p">[[</span><span class="s1">&#39;tree&#39;</span><span class="p">,</span> <span class="s1">&#39;nodeid&#39;</span><span class="p">,</span> <span class="s1">&#39;cvg&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
    <span class="n">draws</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">unique_bnds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">p</span> <span class="o">=</span> <span class="n">unique_bnds</span><span class="p">[</span><span class="s1">&#39;cvg&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trees</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
    <span class="n">sampled_trees_nodes</span> <span class="o">=</span> <span class="n">unique_bnds</span><span class="p">[[</span><span class="s1">&#39;tree&#39;</span><span class="p">,</span><span class="s1">&#39;nodeid&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">draws</span><span class="p">,]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span> <span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="s1">&#39;obs&#39;</span><span class="p">})</span>

    <span class="c1"># Get distributions parameters for each new obs.</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factor_cols</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
      <span class="n">obs_params</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">sampled_trees_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">on</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;tree&quot;</span><span class="p">,</span> <span class="s2">&quot;nodeid&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;obs&#39;</span><span class="p">],</span> <span class="n">ignore_index</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># Get probabilities for each new obs.</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_cols</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
      <span class="n">obs_probs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">sampled_trees_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_probs</span><span class="p">,</span> <span class="n">on</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;tree&quot;</span><span class="p">,</span> <span class="s2">&quot;nodeid&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;obs&#39;</span><span class="p">],</span> <span class="n">ignore_index</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># Sample new data from mixture distribution over trees</span>
    <span class="n">data_new</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">):</span> 
      <span class="n">colname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_colnames</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
      
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_cols</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
        <span class="c1"># Factor columns: Multinomial distribution</span>
        <span class="n">data_new</span><span class="o">.</span><span class="n">isetitem</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">obs_probs</span><span class="p">[</span><span class="n">obs_probs</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">colname</span><span class="p">]</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;obs&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">weights</span> <span class="o">=</span> <span class="s2">&quot;prob&quot;</span><span class="p">)[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span>

      <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Continuous columns: Match estimated distribution parameters with r...() function</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span> <span class="o">==</span> <span class="s2">&quot;truncnorm&quot;</span><span class="p">:</span>
         <span class="c1"># sample from normal distribution, only here for debugging</span>
         <span class="c1"># data_new.loc[:, j] = np.random.normal(obs_params.loc[obs_params[&quot;variable&quot;] == colname, &quot;mean&quot;], obs_params.loc[obs_params[&quot;variable&quot;] == colname, &quot;sd&quot;], size = n) </span>
         
         <span class="c1"># sample from truncated normal distribution</span>
         <span class="c1"># note: if sd == 0, truncnorm will return location parameter -&gt; this is desired; if we have </span>
         <span class="c1"># all obs. in that leave having the same value, we sample a new obs. with exactly that value as well</span>
         <span class="n">myclip_a</span> <span class="o">=</span> <span class="n">obs_params</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">obs_params</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">colname</span><span class="p">,</span> <span class="s2">&quot;min&quot;</span><span class="p">]</span>
         <span class="n">myclip_b</span> <span class="o">=</span> <span class="n">obs_params</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">obs_params</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">colname</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">]</span>
         <span class="n">myloc</span> <span class="o">=</span> <span class="n">obs_params</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">obs_params</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">colname</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">]</span>
         <span class="n">myscale</span> <span class="o">=</span> <span class="n">obs_params</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">obs_params</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">colname</span><span class="p">,</span> <span class="s2">&quot;sd&quot;</span><span class="p">]</span>
         <span class="n">data_new</span><span class="o">.</span><span class="n">isetitem</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">truncnorm</span><span class="p">(</span><span class="n">a</span> <span class="o">=</span><span class="p">(</span><span class="n">myclip_a</span> <span class="o">-</span> <span class="n">myloc</span><span class="p">)</span> <span class="o">/</span> <span class="n">myscale</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">myclip_b</span> <span class="o">-</span> <span class="n">myloc</span><span class="p">)</span> <span class="o">/</span> <span class="n">myscale</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="n">myloc</span> <span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">myscale</span> <span class="p">)</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="n">n</span><span class="p">))</span>
         <span class="k">del</span><span class="p">(</span><span class="n">myclip_a</span><span class="p">,</span><span class="n">myclip_b</span><span class="p">,</span><span class="n">myloc</span><span class="p">,</span><span class="n">myscale</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Other distributions not yet implemented&#39;</span><span class="p">)</span>
    
    <span class="c1"># Use original column names</span>
    <span class="n">data_new</span> <span class="o">=</span> <span class="n">data_new</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig_colnames</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    
    <span class="c1"># Convert categories back to category   </span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_colnames</span><span class="p">:</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_cols</span><span class="p">[</span><span class="n">col</span><span class="p">]:</span>
        <span class="n">data_new</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="o">.</span><span class="n">from_codes</span><span class="p">(</span><span class="n">data_new</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="n">categories</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>

    <span class="c1"># Convert object columns back to object</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_colnames</span><span class="p">:</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">object_cols</span><span class="p">[</span><span class="n">col</span><span class="p">]:</span>
        <span class="n">data_new</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_new</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;object&quot;</span><span class="p">)</span>

    <span class="c1"># Return newly sampled data</span>
    <span class="k">return</span> <span class="n">data_new</span></div></div>


</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Kristin Blesch.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>